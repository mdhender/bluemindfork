<template>
    <bm-extension id="webapp.mail" path="viewer.body" type="chain-of-responsibility" :message="message">
        <div class="body-viewer">
            <mail-top-frame :message="message" />
            <slot name="attachments-block" :files="files" :message="message">
                <files-block
                    :files="files"
                    :message="message"
                    @click-item="previewOrDownload"
                    @remote-content="triggerRemoteContent"
                >
                    <template v-slot:actions="{ file }">
                        <file-toolbar ref="toolbar" :buttons="actionButtons" :file="file" :message="message" />
                    </template>
                    <template #overlay="slotProps">
                        <preview-overlay v-if="slotProps.hasPreview" />
                        <filetype-overlay v-else :file="slotProps.file" />
                    </template>
                </files-block>
            </slot>
            <event-viewer v-if="message.hasICS && currentEvent" :parts="inlines" :message="message">
                <template v-for="(_, slot) of $scopedSlots" v-slot:[slot]="scope">
                    <slot :name="slot" v-bind="scope" />
                </template>
            </event-viewer>
            <mail-inlines-block v-else :message="message" :parts="inlines">
                <template v-for="(_, slot) of $scopedSlots" v-slot:[slot]="scope">
                    <slot :name="slot" v-bind="scope" />
                </template>
            </mail-inlines-block>
        </div>
    </bm-extension>
</template>

<script>
import { mapActions, mapGetters, mapMutations, mapState } from "vuex";
import { MimeType, InlineImageHelper } from "@bluemind/email";
import { BmExtension } from "@bluemind/extensions.vue";
import { hasRemoteImages } from "@bluemind/html-utils";
import { attachmentUtils, fileUtils, partUtils } from "@bluemind/mail";

import { FETCH_PART_DATA } from "~/actions";
import { CONVERSATION_MESSAGE_BY_KEY } from "~/getters";
import { SET_PREVIEW_FILE_KEY, SET_PREVIEW_MESSAGE_KEY } from "~/mutations";

import EventViewer from "./EventViewer";
import FilesBlock from "../MailAttachment/FilesBlock";
import FileToolbar from "../MailAttachment/FileToolbar";
import FiletypeOverlay from "../MailAttachment/Overlays/FiletypeOverlay";
import MailInlinesBlock from "./MailInlinesBlock";
import PreviewOverlay from "../MailAttachment/Overlays/PreviewOverlay";
import MailTopFrame from "./MailTopFrame/MailTopFrame";

const { create: createAttachment } = attachmentUtils;
const { FileStatus, isUploading, isAllowedToPreview, ActionButtons } = fileUtils;
const { VIEWER_CAPABILITIES, getPartsFromCapabilities, isViewable } = partUtils;

export default {
    name: "BodyViewer",
    components: {
        BmExtension,
        EventViewer,
        FilesBlock,
        FileToolbar,
        FiletypeOverlay,
        MailInlinesBlock,
        PreviewOverlay,
        MailTopFrame
    },
    props: {
        message: {
            type: Object,
            required: true
        }
    },
    data() {
        return {
            actionButtons: [ActionButtons.PREVIEW, ActionButtons.DOWNLOAD, ActionButtons.OTHER]
        };
    },
    computed: {
        ...mapState("mail", { currentEvent: state => state.consultPanel.currentEvent }),
        ...mapGetters("mail", { CONVERSATION_MESSAGE_BY_KEY }),
        contents() {
            return this.$store.state.mail.partsData.partsByMessageKey[this.message.key];
        },
        inlines() {
            let contents = this.$store.state.mail.partsData.partsByMessageKey[this.message.key] || [];
            const cids = new CidSet(
                this.parts.flatMap(({ address, mime }) =>
                    MimeType.isHtml({ mime }) && contents[address] ? InlineImageHelper.cids(contents[address]) : []
                )
            );
            return this.parts.filter(part => isViewable(part) && !(MimeType.isImage(part) && cids.has(part.contentId)));
        },
        parts() {
            return getPartsFromCapabilities(this.message, VIEWER_CAPABILITIES);
        },
        files() {
            const fallback = this.parts
                .filter(part => !isViewable(part))
                .map(part => createAttachment(part, FileStatus.ONLY_LOCAL));
            return [
                ...this.message.attachments.map(({ fileKey }) => this.$store.state.mail.files[fileKey]),
                ...fallback
            ];
        }
    },
    async created() {
        const texts = this.parts.filter(part => MimeType.isHtml(part));
        await this.FETCH_PART_DATA({
            messageKey: this.message.key,
            folderUid: this.message.folderRef.uid,
            imapUid: this.message.remoteRef.imapUid,
            parts: texts
        });
        const hasImages = texts.some(part => MimeType.isHtml(part) && hasRemoteImages(this.contents[part.address]));
        if (hasImages) {
            this.triggerRemoteContent();
        }
    },
    methods: {
        ...mapActions("mail", { FETCH_PART_DATA }),
        ...mapMutations("mail", { SET_PREVIEW_MESSAGE_KEY, SET_PREVIEW_FILE_KEY }),
        download(file) {
            this.$refs.toolbar.download(file);
        },
        openPreview(file) {
            this.$refs.toolbar.openPreview(file);
        },
        triggerRemoteContent() {
            this.$emit("remote-content", this.message);
        },
        previewOrDownload(file) {
            if (!isUploading(file)) {
                if (isAllowedToPreview(file)) {
                    this.openPreview(file);
                } else {
                    this.download(file);
                }
            }
        },
        isViewable,
        isAllowedToPreview
    }
};

class CidSet extends Set {
    has(cid) {
        const r = /^<?([^>]*)>?$/;
        return cid && super.has(cid.replace(r, "$1").toUpperCase());
    }
}
</script>

<style lang="scss">
@import "~@bluemind/ui-components/src/css/variables";

.body-viewer {
    display: flex;
    flex-direction: column;
    gap: $sp-5;
}
</style>
